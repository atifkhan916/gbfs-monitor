name: GBFS Deployment

on:
  pull_request:
    types: [closed]
    branches: [dev]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to (dev/prod)'
        required: true
        default: 'dev'

env:
  TF_DIR: './terraform'
  OUTPUT_DIR: './build'
  REACT_APP_DIR: ./src/ui/gbfs-dashboard

jobs:
  test-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Setup Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '20.x'

    - name: Install dependencies
      run: npm ci

    - name: Build TypeScript
      run: npm run build
    
    - name: Prepare Lambda Functions
      run: |
        echo "Creating Lambda deployment packages..."
        
        # Create Lambda deployment packages
        echo "Zipping Lambda functions..."
        
        for lambda_folder in "$OUTPUT_DIR"/*; do
            if [ -d "$lambda_folder" ]; then
                lambda_name=$(basename "$lambda_folder")
                echo "Creating deployment package for $lambda_name"
                (cd "$lambda_folder" && zip -r "../${lambda_name}.zip" .)
                echo "Created ${lambda_name}.zip"
            fi
        done
        
        echo "Lambda deployment packages created successfully"
      shell: bash

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: '1.5.7'

    # New step to read tfvars
    - name: Read Environment Variables
      id: tfvars
      run: |
        if [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.pull_request.merged }}" == "true" && "${{ github.base_ref }}" == "dev" ]]; then
          ENV="dev"
        elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          ENV="${{ github.event.inputs.environment }}"
        else
          echo "No deployment will be performed."
          exit 1
        fi
        
        echo "DEPLOY_ENV=${ENV^^}" >> $GITHUB_ENV
        
        # Read aws_region from tfvars
        AWS_REGION=$(grep 'aws_region' "$TF_DIR/environments/${ENV}.tfvars" | cut -d'=' -f2 | tr -d ' "')
        echo "AWS_REGION=$AWS_REGION" >> $GITHUB_ENV
        
        echo "Environment variables set:"
        echo "DEPLOY_ENV: ${ENV^^}"
        echo "AWS_REGION: $AWS_REGION"

    - name: Configure AWS credentials
      if: env.DEPLOY_ENV == 'DEV' || env.DEPLOY_ENV == 'PROD'
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets[format('GBFS_{0}_AWS_ACCESS_KEY_ID', env.DEPLOY_ENV)] }}
        aws-secret-access-key: ${{ secrets[format('GBFS_{0}_AWS_SECRET_KEY', env.DEPLOY_ENV)] }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform Backend
      if: env.DEPLOY_ENV == 'DEV' || env.DEPLOY_ENV == 'PROD'
      run: |
        chmod +x ./scripts/setup_terraform_backend.sh
        ./scripts/setup_terraform_backend.sh \
          "${{ env.DEPLOY_ENV }}-gbfs-monitoring-terraform-state" \
          "${{ env.AWS_REGION }}"
      shell: bash

    - name: Deploy
      env:
        TF_VAR_environment: ${{ env.DEPLOY_ENV }}
      if: success() && (env.DEPLOY_ENV == 'DEV' || env.DEPLOY_ENV == 'PROD')
      run: |
        if [[ "${{ env.DEPLOY_ENV }}" == "PROD" ]]; then
          echo "Deploying to production environment. Please confirm this action."
          read -p "Type 'yes' to continue: " confirmation
          if [ "$confirmation" != "yes" ]; then
            echo "Production deployment cancelled."
            exit 1
          fi
        fi
        
        echo "Running Terraform commands..."
        cd "$TF_DIR" || exit

        ENV_LOWER=$(echo "${{ env.DEPLOY_ENV }}" | tr '[:upper:]' '[:lower:]')
        BUCKET_NAME="${ENV_LOWER}-gbfs-monitoring-terraform-state"
        VAR_FILE="environments/${ENV_LOWER}.tfvars"
        WORKSPACE_NAME="${ENV_LOWER}"

        echo "Using configuration:"
        echo "Workspace: ${WORKSPACE_NAME}"
        echo "Bucket: ${BUCKET_NAME}"
        echo "Var file: ${VAR_FILE}"

        echo "Initializing Terraform..."
        terraform init \
          -backend-config="bucket=${BUCKET_NAME}" \
          -backend-config="key=terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}"

        echo "Selecting or creating workspace: ${WORKSPACE_NAME}"
        terraform workspace select -or-create ${WORKSPACE_NAME}

        echo "Validating Terraform configuration..."
        terraform validate

        echo "Generating Terraform plan..."
        terraform plan -var-file="${VAR_FILE}" -out=tfplan

        echo "Creating resources..."
        echo "Deploying to ${{ env.DEPLOY_ENV }} environment..."
        terraform apply -auto-approve tfplan

        echo "Script completed!"
      shell: bash

    - name: Get Terraform Outputs
      if: env.DEPLOY_ENV == 'DEV' || env.DEPLOY_ENV == 'PROD'
      id: terraform_outputs
      run: |
        # Get clean outputs using grep to extract the last line of each output
        WEBSOCKET_URL=$(terraform output -raw websocket_url | tail -n1)
        CLOUDFRONT_ID=$(terraform output -raw cloudfront_distribution_id | tail -n1)
        WEBSITE_BUCKET=$(terraform output -raw website_s3_bucket_name | tail -n1)
        
        # Validate outputs
        echo "Validating outputs..."
        
        if [[ -z "$WEBSOCKET_URL" ]]; then
          echo "Error: WebSocket URL is empty"
          exit 1
        fi
        
        if [[ -z "$CLOUDFRONT_ID" ]]; then
          echo "Error: CloudFront ID is empty"
          exit 1
        fi
        
        if [[ -z "$WEBSITE_BUCKET" ]]; then
          echo "Error: Website bucket name is empty"
          exit 1
        fi
        
        # Add wss:// prefix if not present
        if [[ ! "$WEBSOCKET_URL" =~ ^wss:// ]]; then
          WEBSOCKET_URL="wss://${WEBSOCKET_URL}"
        fi
        
        # Save to GITHUB_ENV using a different approach
        {
          echo "WEBSOCKET_URL=${WEBSOCKET_URL}"
          echo "CLOUDFRONT_ID=${CLOUDFRONT_ID}"
          echo "WEBSITE_BUCKET=${WEBSITE_BUCKET}"
        } > "$GITHUB_ENV"
        
        # Print for verification
        echo "Final outputs:"
        echo "WebSocket URL: ${WEBSOCKET_URL}"
        echo "CloudFront ID: ${CLOUDFRONT_ID}"
        echo "Website bucket Name: ${WEBSITE_BUCKET}"
        
        # Additional verification
        if ! curl --output /dev/null --silent --head --fail "${WEBSOCKET_URL/wss/https}"; then
          echo "Warning: WebSocket URL might not be accessible"
        fi
      shell: bash

    - name: Build React App
      run: |
        cd "$REACT_APP_DIR"
        
        # Create .env file with the WebSocket URL from Terraform output
        echo "REACT_APP_WEBSOCKET_URL=${{ env.WEBSOCKET_URL }}" > .env
        
        # Build the React app
        npm run build
      env:
        CI: false

    - name: Deploy to S3
      if: env.DEPLOY_ENV == 'DEV' || env.DEPLOY_ENV == 'PROD'
      run: |
        ENV_LOWER=$(echo "${{ env.DEPLOY_ENV }}" | tr '[:upper:]' '[:lower:]')
        BUCKET_NAME="${ENV_LOWER}-gbfs-monitoring-frontend"
        
        echo "Deploying React app to S3 bucket: $BUCKET_NAME"
        
        # Sync build folder with S3 bucket
        aws s3 sync $REACT_APP_DIR/build/ s3://$BUCKET_NAME --region ${{ env.AWS_REGION }} --delete
        
        # Invalidate CloudFront cache using the ID from Terraform output
        if [[ -n "${{ env.CLOUDFRONT_ID }}" ]]; then
          echo "Invalidating CloudFront cache..."
          aws cloudfront create-invalidation \
            --distribution-id ${{ env.CLOUDFRONT_ID }} \
            --paths "/*"
        fi
